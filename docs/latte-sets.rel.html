<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.rel documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">0.2.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch"><a href="latte-sets.algebra.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>algebra</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li><li class="depth-2 current"><a href="latte-sets.rel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rel</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.rel.html#var-dom"><div class="inner"><span>dom</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-emptyrel"><div class="inner"><span>emptyrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-emptyrel-prop"><div class="inner"><span>emptyrel-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-equivalence"><div class="inner"><span>equivalence</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-fullrel"><div class="inner"><span>fullrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-fullrel-prop"><div class="inner"><span>fullrel-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-equiv"><div class="inner"><span>ident-equiv</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-refl"><div class="inner"><span>ident-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-sym"><div class="inner"><span>ident-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ident-trans"><div class="inner"><span>ident-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-identity"><div class="inner"><span>identity</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-ran"><div class="inner"><span>ran</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rcomp"><div class="inner"><span>rcomp</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-reflexive"><div class="inner"><span>reflexive</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel"><div class="inner"><span>rel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal"><div class="inner"><span>rel-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-implies-releq"><div class="inner"><span>rel-equal-implies-releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-implies-subrel"><div class="inner"><span>rel-equal-implies-subrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-prop"><div class="inner"><span>rel-equal-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-refl"><div class="inner"><span>rel-equal-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-releq"><div class="inner"><span>rel-equal-releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-sym"><div class="inner"><span>rel-equal-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-rel-equal-trans"><div class="inner"><span>rel-equal-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq"><div class="inner"><span>releq</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-implies-rel-equal-ax"><div class="inner"><span>releq-implies-rel-equal-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-refl"><div class="inner"><span>releq-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-sym"><div class="inner"><span>releq-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-releq-trans"><div class="inner"><span>releq-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel"><div class="inner"><span>subrel</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-refl"><div class="inner"><span>subrel-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-subrel-trans"><div class="inner"><span>subrel-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-symmetric"><div class="inner"><span>symmetric</span></div></a></li><li class="depth-1"><a href="latte-sets.rel.html#var-transitive"><div class="inner"><span>transitive</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.rel</h1><div class="doc"><div class="markdown"><p>A <strong>relation</strong> from elements of a given type <code>T</code> to elements of <code>U</code> is formalized with type <code>(==&gt; T U :type)</code>.</p>
<p>This namespace provides some important properties about such  relations.</p></div></div><div class="public anchor" id="var-dom"><h3>dom</h3><div class="usage"><code>(dom [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (exists [y U] (R x y)))
</code></pre>
<p><strong>Definition</strong>: The domain of relation <code>R</code>.</p></div></div></div><div class="public anchor" id="var-emptyrel"><h3>emptyrel</h3><div class="usage"><code>(emptyrel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] p/absurd))
</code></pre>
<p><strong>Definition</strong>: The empty relation.</p></div></div></div><div class="public anchor" id="var-emptyrel-prop"><h3>emptyrel-prop</h3><div class="usage"><code>(emptyrel-prop [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] (not ((emptyrel T U) x y))))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-equivalence"><h3>equivalence</h3><div class="usage"><code>(equivalence [T :type] [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (reflexive T R) (and (symmetric T R) (transitive T R)))
</code></pre>
<p><strong>Definition</strong>: An equivalence relation.</p></div></div></div><div class="public anchor" id="var-fullrel"><h3>fullrel</h3><div class="usage"><code>(fullrel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [y U] p/truth))
</code></pre>
<p><strong>Definition</strong>: The full (total) relation between <code>T</code> and <code>U</code>.</p></div></div></div><div class="public anchor" id="var-fullrel-prop"><h3>fullrel-prop</h3><div class="usage"><code>(fullrel-prop [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] ((fullrel T U) x y)))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-ident-equiv"><h3>ident-equiv</h3><div class="usage"><code>(ident-equiv [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(equivalence T (identity T))
</code></pre>
<p><strong>Theorem</strong>: The indentity on <code>T</code> is an equivalence relation.</p></div></div></div><div class="public anchor" id="var-ident-refl"><h3>ident-refl</h3><div class="usage"><code>(ident-refl [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(reflexive T (identity T))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-ident-sym"><h3>ident-sym</h3><div class="usage"><code>(ident-sym [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(symmetric T (identity T))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-ident-trans"><h3>ident-trans</h3><div class="usage"><code>(ident-trans [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(transitive T (identity T))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-identity"><h3>identity</h3><div class="usage"><code>(identity [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x y T] (equal T x y))
</code></pre>
<p><strong>Definition</strong>: The indentity relation on <code>T</code>.</p></div></div></div><div class="public anchor" id="var-ran"><h3>ran</h3><div class="usage"><code>(ran [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [y U] (exists [x T] (R x y)))
</code></pre>
<p><strong>Definition</strong>: The range of relation <code>R</code>.</p></div></div></div><div class="public anchor" id="var-rcomp"><h3>rcomp</h3><div class="usage"><code>(rcomp [T :type] [U :type] [V :type] [R1 (rel T U)] [R2 (rel U V)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (lambda [z V] (exists [y U] (and (R1 x y) (R2 y z)))))
</code></pre>
<p><strong>Definition</strong>: Sequential relational composition.</p></div></div></div><div class="public anchor" id="var-reflexive"><h3>reflexive</h3><div class="usage"><code>(reflexive [T :type] [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (R x x))
</code></pre>
<p><strong>Definition</strong>: A reflexive relation.</p></div></div></div><div class="public anchor" id="var-rel"><h3>rel</h3><div class="usage"><code>(rel [T :type] [U :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; T U :type)
</code></pre>
<p><strong>Definition</strong>: The type of relations.</p></div></div></div><div class="public anchor" id="var-rel-equal"><h3>rel-equal</h3><div class="usage"><code>(rel-equal [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [P (==&gt; (rel T U) :type)] (&lt;=&gt; (P R1) (P R2)))
</code></pre>
<p><strong>Definition</strong>: A <em>Leibniz</em>-stype equality for relations.</p>
<p>It says that two relations <code>R1</code> and <code>R2</code> are equal iff for any predicate <code>P</code> then <code>(P R1)</code> if and only if <code>(P R2)</code>.</p>
<p>Note that the identification with <a href="latte-sets.core.html#var-seteq">seteq</a> is non-trivial,  and requires an axiom.</p></div></div></div><div class="public anchor" id="var-rel-equal-implies-releq"><h3>rel-equal-implies-releq</h3><div class="usage"><code>(rel-equal-implies-releq [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal T U R1 R2) (releq T U R1 R2))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-rel-equal-implies-subrel"><h3>rel-equal-implies-subrel</h3><div class="usage"><code>(rel-equal-implies-subrel [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal T U R1 R2) (subrel T U R1 R2))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-rel-equal-prop"><h3>rel-equal-prop</h3><div class="usage"><code>(rel-equal-prop [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [P (==&gt; (rel T U) :type)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal T U R1 R2) (P R1) (P R2))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-rel-equal-refl"><h3>rel-equal-refl</h3><div class="usage"><code>(rel-equal-refl [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(rel-equal T U R R)
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-rel-equal-releq"><h3>rel-equal-releq</h3><div class="usage"><code>(rel-equal-releq [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (rel-equal T U R1 R2) (releq T U R1 R2))
</code></pre>
<p><strong>Theorem</strong>: Coincidence of <em>Leibniz</em>-style and subset-based equality for relations.</p></div></div></div><div class="public anchor" id="var-rel-equal-sym"><h3>rel-equal-sym</h3><div class="usage"><code>(rel-equal-sym [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal T U R1 R2) (rel-equal T U R2 R1))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-rel-equal-trans"><h3>rel-equal-trans</h3><div class="usage"><code>(rel-equal-trans [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (rel-equal T U R1 R2) (rel-equal T U R2 R3) (rel-equal T U R1 R3))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-releq"><h3>releq</h3><div class="usage"><code>(releq [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subrel T U R1 R2) (subrel T U R2 R1))
</code></pre>
<p><strong>Definition</strong>: Subset-based equality on relations.</p></div></div></div><div class="public anchor" id="var-releq-implies-rel-equal-ax"><h3>releq-implies-rel-equal-ax</h3><div class="usage"><code>(releq-implies-rel-equal-ax [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq T U R1 R2) (rel-equal T U R1 R2))
</code></pre>
<p><strong>Axiom</strong>: As for the set case (cf. <a href="null">sets/seteq-implies-set-equal-ax</a>), going from the subset-based equality to the (thus more general) <em>leibniz</em>-style one requires an axiom.</p></div></div></div><div class="public anchor" id="var-releq-refl"><h3>releq-refl</h3><div class="usage"><code>(releq-refl [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(releq T U R R)
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-releq-sym"><h3>releq-sym</h3><div class="usage"><code>(releq-sym [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq T U R1 R2) (releq T U R2 R1))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-releq-trans"><h3>releq-trans</h3><div class="usage"><code>(releq-trans [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (releq T U R1 R2) (releq T U R2 R3) (releq T U R1 R3))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-subrel"><h3>subrel</h3><div class="usage"><code>(subrel [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (forall [y U] (==&gt; (R1 x y) (R2 x y))))
</code></pre>
<p><strong>Definition</strong>: The subser ordering for relations.</p></div></div></div><div class="public anchor" id="var-subrel-refl"><h3>subrel-refl</h3><div class="usage"><code>(subrel-refl [T :type] [U :type] [R (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(subrel T U R R)
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-subrel-trans"><h3>subrel-trans</h3><div class="usage"><code>(subrel-trans [T :type] [U :type] [R1 (rel T U)] [R2 (rel T U)] [R3 (rel T U)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (subrel T U R1 R2) (subrel T U R2 R3) (subrel T U R1 R3))
</code></pre>
<p><strong>Theorem</strong>: No documentation.</p></div></div></div><div class="public anchor" id="var-symmetric"><h3>symmetric</h3><div class="usage"><code>(symmetric [T :type] [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x y T] (==&gt; (R x y) (R y x)))
</code></pre>
<p><strong>Definition</strong>: A symmetric relation.</p></div></div></div><div class="public anchor" id="var-transitive"><h3>transitive</h3><div class="usage"><code>(transitive [T :type] [R (rel T T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x y z T] (==&gt; (R x y) (R y z) (R x z)))
</code></pre>
<p><strong>Definition</strong>: A transitive relation.</p></div></div></div></div></body></html>
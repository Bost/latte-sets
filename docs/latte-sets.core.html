<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>latte-sets.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Latte-sets</span> <span class="project-version">0.1.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>latte-sets</span></div></div></li><li class="depth-2 branch current"><a href="latte-sets.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="latte-sets.powerset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>powerset</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="latte-sets.core.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-elem"><div class="inner"><span>elem</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-emptyset"><div class="inner"><span>emptyset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-emptyset-prop"><div class="inner"><span>emptyset-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-emptyset-subset-lower-bound"><div class="inner"><span>emptyset-subset-lower-bound</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-exists-in"><div class="inner"><span>exists-in</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-forall-in"><div class="inner"><span>forall-in</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-fullset"><div class="inner"><span>fullset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-fullset-intro"><div class="inner"><span>fullset-intro</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-intersection"><div class="inner"><span>intersection</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-intersection-commute"><div class="inner"><span>intersection-commute</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-intersection-elim-left"><div class="inner"><span>intersection-elim-left</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-intersection-elim-right"><div class="inner"><span>intersection-elim-right</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-proper-subset"><div class="inner"><span>proper-subset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set"><div class="inner"><span>set</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal"><div class="inner"><span>set-equal</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-implies-seteq"><div class="inner"><span>set-equal-implies-seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-implies-subset"><div class="inner"><span>set-equal-implies-subset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-refl"><div class="inner"><span>set-equal-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-seteq"><div class="inner"><span>set-equal-seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-sym"><div class="inner"><span>set-equal-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-set-equal-trans"><div class="inner"><span>set-equal-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq"><div class="inner"><span>seteq</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-implies-set-equal-ax"><div class="inner"><span>seteq-implies-set-equal-ax</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-refl"><div class="inner"><span>seteq-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-sym"><div class="inner"><span>seteq-sym</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-seteq-trans"><div class="inner"><span>seteq-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset"><div class="inner"><span>subset</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-prop"><div class="inner"><span>subset-prop</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-refl"><div class="inner"><span>subset-refl</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-subset-trans"><div class="inner"><span>subset-trans</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="latte-sets.core.html#var-union-commute"><div class="inner"><span>union-commute</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">latte-sets.core</h1><div class="doc"><div class="markdown"><p>Set-theoretic notions based on the subset  approach of type theory.</p>
<p>The main idea is to consider a typed variant of  a mathematical set as a predicate over a given type.</p>
<p>What is called a <strong>set</strong> will be technically-speaking  a subset of a type, hence a predicate over a given type.  This means that the set theory developed here is <em>typed</em>  and thus quite different than the standard axiomatic set theories (e.g. ZF and ZFC), which are essentially untyped.</p>
<p>But many set-theoretic constructions and results have a natural translation to the typed setting.</p></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (and (elem T x s1) (not (elem T x s2))))
</code></pre>
<p><strong>Definition</strong>: Set difference</p>
<p><code>(difference T s1 s2)</code> is the set <code>s1</code>∖<code>s2</code>.</p></div></div></div><div class="public anchor" id="var-elem"><h3>elem</h3><div class="usage"><code>(elem [T :type] [x T] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(s x)
</code></pre>
<p><strong>Definition</strong>: Set membership. </p>
<p>Given a type <code>T</code>, a value <code>x</code> of type <code>T</code> and  a set <code>s</code>, then <code>(elem T x s)</code> means that <code>x</code> is an element of set <code>s</code>.  The standard mathematical notation is: <code>x</code>∊<code>s</code> (leaving the type <code>T</code> implicit).</p></div></div></div><div class="public anchor" id="var-emptyset"><h3>emptyset</h3><div class="usage"><code>(emptyset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] p/absurd)
</code></pre>
<p><strong>Definition</strong>: The empty set of a type.</p></div></div></div><div class="public anchor" id="var-emptyset-prop"><h3>emptyset-prop</h3><div class="usage"><code>(emptyset-prop [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (not (elem T x (emptyset T))))
</code></pre>
<p><strong>Theorem</strong>: The main property of the empty set.</p></div></div></div><div class="public anchor" id="var-emptyset-subset-lower-bound"><h3>emptyset-subset-lower-bound</h3><div class="usage"><code>(emptyset-subset-lower-bound [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subset T (emptyset T) s)
</code></pre>
<p><strong>Theorem</strong>: The emptyset is a subset of every other sets.</p></div></div></div><div class="public anchor" id="var-exists-in"><h3>exists-in</h3><div class="usage"><code>(exists-in binding body)</code></div><div class="doc"><div class="markdown"><p>Existential quantification over sets.</p>
<p><code>(exists-in [x T s] (P x))</code> is a shortcut for <code>(exists [x T]
                 (and (elem T x s)
                      (P x)))</code>.</p></div></div></div><div class="public anchor" id="var-forall-in"><h3>forall-in</h3><div class="usage"><code>(forall-in binding body)</code></div><div class="doc"><div class="markdown"><p>Universal quantification over sets.</p>
<p><code>(forall-in [x T s] (P x))</code> is a shortcut for <code>(forall [x T]
                 (==&gt; (elem T x s)
                      (P x)))</code>.</p></div></div></div><div class="public anchor" id="var-fullset"><h3>fullset</h3><div class="usage"><code>(fullset [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] p/truth)
</code></pre>
<p><strong>Definition</strong>: The full set of a type (all the inhabitants of the type are element of the full set).</p></div></div></div><div class="public anchor" id="var-fullset-intro"><h3>fullset-intro</h3><div class="usage"><code>(fullset-intro [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (elem T x (fullset T)))
</code></pre>
<p><strong>Theorem</strong>: Introduction rule for the full set.</p></div></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><div class="usage"><code>(intersection [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (and (elem T x s1) (elem T x s2)))
</code></pre>
<p><strong>Definition</strong>: Set intersection.</p>
<p><code>(intersection T s1 s2)</code> is the set <code>s1</code>∩<code>s2</code>.</p></div></div></div><div class="public anchor" id="var-intersection-commute"><h3>intersection-commute</h3><div class="usage"><code>(intersection-commute [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(seteq T (intersection T s1 s2) (intersection T s2 s1))
</code></pre>
<p><strong>Theorem</strong>: Set intersection commutes.</p></div></div></div><div class="public anchor" id="var-intersection-elim-left"><h3>intersection-elim-left</h3><div class="usage"><code>(intersection-elim-left [T :type] [s1 (set T)] [s2 (set T)] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem T x (intersection T s1 s2)) (elem T x s1))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for intersection (left operand).</p></div></div></div><div class="public anchor" id="var-intersection-elim-right"><h3>intersection-elim-right</h3><div class="usage"><code>(intersection-elim-right [T :type] [s1 (set T)] [s2 (set T)] [x T])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (elem T x (intersection T s1 s2)) (elem T x s2))
</code></pre>
<p><strong>Theorem</strong>: Elimination rule for intersection (right operand).</p></div></div></div><div class="public anchor" id="var-proper-subset"><h3>proper-subset</h3><div class="usage"><code>(proper-subset [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subset T s1 s2) (not (seteq T s1 s2)))
</code></pre>
<p><strong>Definition</strong>: The anti-reflexive variant of the subset relation.</p>
<p>The expression <code>(proper-subset T s1 s2)</code> means that  the set <code>s1</code> is a subset of <code>s2</code>, but that the two sets are distinct, i.e. <code>s1</code>⊂<code>s2</code> (or more explicitely <code>s1</code>⊊<code>s2</code>).</p></div></div></div><div class="public anchor" id="var-set"><h3>set</h3><div class="usage"><code>(set [T :type])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; T :type)
</code></pre>
<p><strong>Definition</strong>: The type of sets whose elements are of type <code>T</code>.</p></div></div></div><div class="public anchor" id="var-set-equal"><h3>set-equal</h3><div class="usage"><code>(set-equal [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [P (==&gt; (set T) :type)] (&lt;=&gt; (P s1) (P s2)))
</code></pre>
<p><strong>Definition</strong>: A <em>Leibniz</em>-stype equality for sets.</p>
<p>It says that two sets <code>s1</code> and <code>s2</code> are equal iff for any predicate <code>P</code> then <code>(P s1)</code> if and only if <code>(P s2)</code>.</p>
<p>Note that the identification with <a href="latte-sets.core.html#var-seteq">seteq</a> is non-trivial,  and requires an axiom.</p></div></div></div><div class="public anchor" id="var-set-equal-implies-seteq"><h3>set-equal-implies-seteq</h3><div class="usage"><code>(set-equal-implies-seteq [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal T s1 s2) (seteq T s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Subset-based equality implies <em>Leibniz</em>-style equality on sets.</p></div></div></div><div class="public anchor" id="var-set-equal-implies-subset"><h3>set-equal-implies-subset</h3><div class="usage"><code>(set-equal-implies-subset [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal T s1 s2) (subset T s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Going from <em>Leibniz</em> equality on sets to the subset relation is easy.</p></div></div></div><div class="public anchor" id="var-set-equal-refl"><h3>set-equal-refl</h3><div class="usage"><code>(set-equal-refl [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(set-equal T s s)
</code></pre>
<p><strong>Theorem</strong>: Reflexivity of set equality.</p></div></div></div><div class="public anchor" id="var-set-equal-seteq"><h3>set-equal-seteq</h3><div class="usage"><code>(set-equal-seteq [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(&lt;=&gt; (seteq T s1 s2) (set-equal T s1 s2))
</code></pre>
<p><strong>Theorem</strong>: Set equality and subset-based equality (should) coincide (axiomatically).</p></div></div></div><div class="public anchor" id="var-set-equal-sym"><h3>set-equal-sym</h3><div class="usage"><code>(set-equal-sym [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal T s1 s2) (set-equal T s2 s1))
</code></pre>
<p><strong>Theorem</strong>: Symmetry of set equality.</p></div></div></div><div class="public anchor" id="var-set-equal-trans"><h3>set-equal-trans</h3><div class="usage"><code>(set-equal-trans [T :type] [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (set-equal T s1 s2) (set-equal T s2 s3) (set-equal T s1 s3))
</code></pre>
<p><strong>Theorem</strong>: Transitivity of set equality.</p></div></div></div><div class="public anchor" id="var-seteq"><h3>seteq</h3><div class="usage"><code>(seteq [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(and (subset T s1 s2) (subset T s2 s1))
</code></pre>
<p><strong>Definition</strong>: Equality on sets.</p>
<p>This is a natural equality on sets based on the subset relation.</p></div></div></div><div class="public anchor" id="var-seteq-implies-set-equal-ax"><h3>seteq-implies-set-equal-ax</h3><div class="usage"><code>(seteq-implies-set-equal-ax [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq T s1 s2) (set-equal T s1 s2))
</code></pre>
<p><strong>Axiom</strong>: Going from subset-based equality to <em>Leibniz</em>-style equality requires this axiom. This is because we cannot lift membership  to an arbitrary predicate.</p></div></div></div><div class="public anchor" id="var-seteq-refl"><h3>seteq-refl</h3><div class="usage"><code>(seteq-refl [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(seteq T s s)
</code></pre>
<p><strong>Theorem</strong>: Set equality is reflexive.</p></div></div></div><div class="public anchor" id="var-seteq-sym"><h3>seteq-sym</h3><div class="usage"><code>(seteq-sym [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq T s1 s2) (seteq T s2 s1))
</code></pre>
<p><strong>Theorem</strong>: Set equality is symmetric.</p></div></div></div><div class="public anchor" id="var-seteq-trans"><h3>seteq-trans</h3><div class="usage"><code>(seteq-trans [T :type] [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (seteq T s1 s2) (seteq T s2 s3) (seteq T s1 s3))
</code></pre>
<p><strong>Theorem</strong>: Set equality is transitive.</p></div></div></div><div class="public anchor" id="var-subset"><h3>subset</h3><div class="usage"><code>(subset [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(forall [x T] (==&gt; (elem T x s1) (elem T x s2)))
</code></pre>
<p><strong>Definition</strong>: The subset relation for type <code>T</code>.</p>
<p>The expression <code>(subset T s1 s2)</code> means that  the set <code>s1</code> is a subset of <code>s2</code>, i.e. <code>s1</code>⊆<code>s2</code>.</p></div></div></div><div class="public anchor" id="var-subset-prop"><h3>subset-prop</h3><div class="usage"><code>(subset-prop [T :type] [P (==&gt; T :type)] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt;
 (forall [x T] (==&gt; (elem T x s2) (P x)))
 (subset T s1 s2)
 (forall [x T] (==&gt; (elem T x s1) (P x))))
</code></pre>
<p><strong>Theorem</strong>: Preservation of properties on subsets.</p></div></div></div><div class="public anchor" id="var-subset-refl"><h3>subset-refl</h3><div class="usage"><code>(subset-refl [T :type] [s (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(subset T s s)
</code></pre>
<p><strong>Theorem</strong>: The subset relation is reflexive.</p></div></div></div><div class="public anchor" id="var-subset-trans"><h3>subset-trans</h3><div class="usage"><code>(subset-trans [T :type] [s1 (set T)] [s2 (set T)] [s3 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(==&gt; (subset T s1 s2) (subset T s2 s3) (subset T s1 s3))
</code></pre>
<p><strong>Theorem</strong>: The subset relation is transitive.</p></div></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(lambda [x T] (or (elem T x s1) (elem T x s2)))
</code></pre>
<p><strong>Definition</strong>: Set union.</p>
<p><code>(union T s1 s2)</code> is the set <code>s1</code>∪<code>s2</code>.</p></div></div></div><div class="public anchor" id="var-union-commute"><h3>union-commute</h3><div class="usage"><code>(union-commute [T :type] [s1 (set T)] [s2 (set T)])</code></div><div class="doc"><div class="markdown"><pre><code>(seteq T (union T s1 s2) (union T s2 s1))
</code></pre>
<p><strong>Theorem</strong>: Set union commutes.</p></div></div></div></div></body></html>